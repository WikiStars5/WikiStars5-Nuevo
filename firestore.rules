
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Global Helper Functions ---
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    function isIncrement(field, count) {
        let nextValue = request.resource.data[field];
        let prevValue = resource.data[field];
        return nextValue == prevValue + count;
    }

    function isVoteIncrement(voteType, voteField) {
        let nextVoteMap = request.resource.data[voteType];
        let prevVoteMap = resource.data[voteType];
        
        // Check if only the specific vote field is being incremented by 1
        return nextVoteMap[voteField] == prevVoteMap[voteField] + 1 &&
               nextVoteMap.diff(prevVoteMap).affectedKeys().hasOnly([voteField]);
    }
    
    function isVoteDecrement(voteType, voteField) {
        let nextVoteMap = request.resource.data[voteType];
        let prevVoteMap = resource.data[voteType];

        // Check if only the specific vote field is being decremented by 1
        return nextVoteMap[voteField] == prevVoteMap[voteField] - 1 &&
               nextVoteMap.diff(prevVoteMap).affectedKeys().hasOnly([voteField]);
    }

    function isChangingVote(voteType, oldVoteField, newVoteField) {
        let nextVoteMap = request.resource.data[voteType];
        let prevVoteMap = resource.data[voteType];

        // Check if old vote is decremented and new vote is incremented, and nothing else changed.
        return nextVoteMap[oldVoteField] == prevVoteMap[oldVoteField] - 1 &&
               nextVoteMap[newVoteField] == prevVoteMap[newVoteField] + 1 &&
               nextVoteMap.diff(prevVoteMap).affectedKeys().hasOnly([oldVoteField, newVoteField]);
    }
    
    // --- User Data Collections ---

    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isOwner(userId) || isAdmin();

      // Rules for user's private subcollections
      match /attitudeVotes/{figureId} {
        allow get, write: if isOwner(userId);
        allow list: if isOwner(userId);
      }
      match /emotionVotes/{figureId} {
        allow get, write: if isOwner(userId);
        allow list: if isOwner(userId);
      }
       match /streaks/{streakId} {
        allow get, list, write: if isOwner(userId);
      }
      match /user_achievements/{achievementId} {
        allow get, list, write: if isOwner(userId);
      }
      match /notifications/{notificationId} {
          allow read, update, delete: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isSignedIn();
      }
      match /referrals/{referredUserId} {
        allow read, write: if isOwner(userId);
      }
    }

    match /status/{userId} {
      allow read, write: if isOwner(userId);
      allow list: if false;
    }

    match /usernames/{username} {
      allow get: if true; 
      allow list: if false;
      allow create: if isSignedIn(); 
      allow delete: if get(/databases/$(database)/documents/usernames/$(username)).data.userId == request.auth.uid;
      allow update: if false;
    }

    // --- Figure Data Collections ---

    match /figures/{figureId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow delete: if isAdmin();
      
      allow update: if isSignedIn() && (
        // Allow authorized users to edit biographical data
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'name', 'imageUrl', 'imageHint', 'nationality', 'tags', 'tagsLower', 'description', 
            'gender', 'birthDate', 'deathDate', 'occupation', 'maritalStatus', 'height', 'socialLinks', 'nameKeywords'
        ])) ||
        // Allow atomic increments for attitude/emotion votes based on a corresponding user vote document
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attitude', 'emotion']) &&
          (
            isVoteIncrement('attitude', request.resource.data.attitude) || isVoteDecrement('attitude', resource.data.attitude) ||
            isChangingVote('attitude', resource.data.attitude, request.resource.data.attitude) ||
            isVoteIncrement('emotion', request.resource.data.emotion) || isVoteDecrement('emotion', resource.data.emotion) ||
            isChangingVote('emotion', resource.data.emotion, request.resource.data.emotion)
          )
        ) ||
        // Allow atomic increments for ratings
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['ratingCount', 'totalRating', 'ratingsBreakdown']) && isIncrement('ratingCount', 1))
      );
      
      // Rules for public-facing subcollections within figures
      match /attitudeVotes/{userId} {
          allow get, write: if isOwner(userId);
      }
      match /emotionVotes/{userId} {
          allow get, write: if isOwner(userId);
      }

// --- /figures/{figureId}/comments/{commentId} ---
match /comments/{commentId} {
  allow get, list: if true;
  allow create: if isSignedIn();
  allow update: if isSignedIn() && (
    (resource.data.userId == request.auth.uid && request.resource.data.text != resource.data.text) ||
    isIncrement('likes', 1) || isIncrement('dislikes', 1) || isIncrement('likes', -1) || isIncrement('dislikes', -1)
  );
  allow delete: if 
    // Allow if user is the owner of the comment
    resource.data.userId == request.auth.uid ||
    // OR if user is the owner of the parent comment (to delete replies)
    (resource.data.parentId != null && get(/databases/$(database)/documents/figures/$(figureId)/comments/$(resource.data.parentId)).data.userId == request.auth.uid) ||
    // OR if user is an admin
    isAdmin();

  match /votes/{userId} {
    allow get, write: if isOwner(userId);
    allow list: if false;
  }

  //  NUEVO BLOQUE: Reglas para la subcolecci贸n de respuestas (replies)
  // Ruta: /figures/{figureId}/comments/{commentId}/replies/{replyId}
  match /replies/{replyId} {
    // Lectura: Todos pueden leer las respuestas
    allow get, list: if true;

    // Creaci贸n: Solo usuarios autenticados
    allow create: if isSignedIn();

    // Actualizaci贸n: Solo due帽o (texto) o cualquiera (likes/dislikes)
    allow update: if isSignedIn() && (
      (resource.data.userId == request.auth.uid && request.resource.data.text != resource.data.text) ||
      isIncrement('likes', 1) || isIncrement('dislikes', 1) || isIncrement('likes', -1) || isIncrement('dislikes', -1)
    );

    // Borrado: Due帽o del reply, due帽o del comentario padre, o Admin
    allow delete: if 
      resource.data.userId == request.auth.uid ||
      get(/databases/$(database)/documents/figures/$(figureId)/comments/$(commentId)).data.userId == request.auth.uid ||
      isAdmin();
      
    // Votos (Likes/Dislikes) para los Replies
    match /votes/{userId} {
      allow get, write: if isOwner(userId);
      allow list: if false;
    }
  }
}

      // --- /figures/{figureId}/streaks/{userId} ---
      // This is for the public leaderboard on the figure's page.
      match /streaks/{userId} {
        allow read, list: if true; 
        allow write: if isOwner(userId);
      }

       // --- /figures/{figureId}/achievements/{userAchievementId} ---
       // This is for the public achievement board on the figure's page.
      match /achievements/{userAchievementId} {
          allow read, list: if true;
          allow create: if isSignedIn(); // System/user can grant achievement
          allow delete, update: if false; // Achievements are permanent per figure
      }
    }
    
    // --- Other Root-Level Collections ---

    match /hashtags/{hashtagId} {
        allow get, list: if true;
        allow write: if isSignedIn();
    }
    
     match /achievements/{achievementId} {
        allow get, list: if true;
        allow write: if isAdmin(); // Only admins can define master achievements
    }


    match /related_figures/{relatedFigureId} {
      allow get, list: if true;
      allow create, delete: if isSignedIn();
      allow update: if false;
    }

match /goat_battles/{battleId} {
    allow get, list: if true; 
    allow create, delete: if isAdmin(); // Solo el Admin puede crear/borrar
    
    allow update: if (
        // Permiso 1: El administrador puede actualizar cualquier campo
        isAdmin() ||
        
        // Permiso 2: Cualquier usuario autenticado puede incrementar los votos (isIncrement)
        (isSignedIn() && (
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['messiVotes']) && (isIncrement('messiVotes', 1) || isIncrement('messiVotes', -1))) ||
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['ronaldoVotes']) && (isIncrement('ronaldoVotes', 1) || isIncrement('ronaldoVotes', -1)))
        ))
    );
    
    // El resto de la subcolecci贸n de votos queda igual
    match /votes/{userId} {
        allow get, write: if isOwner(userId);
        allow list: if false;
    }
}
    
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow write: if isAdmin();
      allow list: if false;
      
    }
    
    match /settings/{settingId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();      
      
    }
  }
}
